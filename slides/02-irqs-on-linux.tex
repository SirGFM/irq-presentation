\section{IRQs on Linux}

\begin{frame}{\secname}
    Linux detects IRQ and allows drivers to register function for handling specific IRQ.

    \begin{itemize}
        \item A device may register an interrupt handler whenever
        \begin{itemize}
            \item init()
            \item open()
        \end{itemize}
        \item As soon as a handler is assigned to an interrupt number, that interrupt is blocked to the handler until its freed
        \item Since interrupt lines is a scarce resource, they should be registered only while actively in use
    \end{itemize}
\end{frame}



\defverbatim[colored]\regIrqList{
    \begin{lstlisting}[basicstyle=\tiny, language=C]
int request_irq(unsigned int irq,
                irqreturn_t (*handler)(int, void *, struct pt_regs *),
                unsigned long flags,
                const char *dev_name,
                void *dev_id);
    \end{lstlisting}
}

\begin{frame}{\secname}
    To register an interrupt line:

    \regIrqList

    \begin{itemize}
        \item irq: Interrupt number
        \item handler: Interrupt handler
        \item flags: "Fast", shared etc
        \item dev\_name: Displayed in /proc/interrupt
        \item dev\_id: Custom data supplied to the handler (e.g., handle acquired on an open() call)
    \end{itemize}
\end{frame}


\defverbatim[colored]\freeIrqList{
    \begin{lstlisting}[basicstyle=\tiny, language=C]
void free_irq(unsigned int irq, void *dev_id);
    \end{lstlisting}
}

\begin{frame}{\secname}
    To release an interrupt line:

    \freeIrqList

    \begin{itemize}
        \item irq: Interrupt number
        \item dev\_id: Same data supplied on the register call; Useful when releasing a shared handler
    \end{itemize}
\end{frame}

\defverbatim[colored]\sharedIrqList{
    \begin{lstlisting}[basicstyle=\tiny, language=C]
irqreturn_t handler(int irq, void *dev_id, struct pt_regs *regs)
{
    int value;

    /* Check if the interrupt was generated by this device */
    value = inb(SOME_ADDRESS);
    if (!(value & 0x80))
        return IRQ_NONE;
    /* clear the interrupting bit */
    outb(value & 0x7F, SOME_ADDRESS);

    /* Handle the interrupt */

    /* Signal that the interrupt was handled */
    return IRQ_HANDLED;
}
    \end{lstlisting}
}

\begin{frame}{\secname}
    By default, each interrupt can be handled by a single function.

    However, if the interrupt line if free or if every handler is shared as well, then new handlers may be registered as shared (as long as the device can detect that it originated the interrupt).

    \sharedIrqList
\end{frame}


\begin{frame}{\secname}
    One of the flags that may be specified when registering an interrupt says whether it's a "fast" interrupt or a "slow" one.

    \begin{itemize}
        \item Slow interrupts run with interrupts enabled on that processor
        \begin{itemize}
            \item Preferred type, "except for really specific cases"
            \item E.g., timer interrupt
        \end{itemize}
        \item Fast interrupts run with interrupts disabled for that processor
        \begin{itemize}
            \item Other processors may handle other interrupts normally
            \item However, no two processors may handle the same IRQ at the same time
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{\secname}
    Interrupts should execute quickly, but some (package arrival on a network device) require lengthy computations.

    This may be solved by splitting the handler in two halves:

    \begin{itemize}
        \item Top half:
        \begin{itemize}
            \item Actually handles the interrupt
            \item (read from device) Simply queues the received data
            \item (write into device) Simply dequeue data and pump it into the device
            \item Wake up the bottom half to do more work
        \end{itemize}
        \item Bottom half:
        \begin{itemize}
            \item (read from device) Operates on the received data
            \item (write into device) Queues more data into the driver
            \item May be one of two types:
            \begin{itemize}
                \item Tasklet
                \item Workqueue
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{\secname}
    \begin{itemize}
        \item Tasklet
        \begin{itemize}
            \item Run in software interrupt context
            \begin{itemize}
                \item May be preempted by an interrupt
                \item But cannot sleep!
                \item But cannot copy to/read from user space!
            \end{itemize}
            \item May be schedule more than once, but runs only once when launched
            \begin{itemize}
                \item The tasklet must account for it being scheduled more than once
            \end{itemize}
            \item Always executed as a single instance (even across processors)
            \item But may execute concurrently to another tasklet in another processor
        \end{itemize}
        \item Workqueue
        \begin{itemize}
            \item Run in a special worker process
            \begin{itemize}
                \item Can sleep
                \item Also (usually) cannot copy to/read from user space
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}
